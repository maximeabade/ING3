# TD 3 : CHIFFREMENTS SYMÉTRIQUES MODERNES

## Exo 1 : Chiffrement par flot avec des LFSR

On a P(X) = 1 + X + X³ + X⁴ + X⁷ + X⁸
<!--
This document contains instructions for calculating the first 16 bits of the sequence generated by a Linear Feedback Shift Register (LFSR) initialized to 0x5A. The polynomial used is P(X) = 1 + X + X³ + X⁴ + X⁷ + X⁸, indicating an LFSR of size 8.
-->
### 1 : Calculer les 16 premiers bits de la suite générée par le LFSR initialisé à 0x5A

On a P(X) = 1 + X + X³ + X⁴ + X⁷ + X⁸
On a donc un LFSR de taille 8.

0x5A = 01011010 en binaire

**INSERER IMAGE ICIIIIII tableau des registres**

### 8:
On effectue la même procedure que pour le chiffrement mais avec un left shift et en faisant miroir sur la clé (en gros, on fait la même chose mais à l'envers)


### Q10:
On aura des cycles remplis de 0 et de longueur identique a celle du vecteur tout à 0. La période minimale d un LFSR est sa longueur

### Q11:
2^n valeurs prenables pour un registre de taille n 

sa période maximale est donc 2^n 

2⁶⁴  = 18446744073709551616


### Q12:
Le resultat du XOR sera tjrs egal au bit de sortie , donc on a une periodicité de 32. 


KPA CCA CPA
https://www.reddit.com/r/cryptography/comments/14pydtr/struggling_with_indcpacca_game_in_symmetric/?tl=fr

## Exo 2 : Chiffrement par bloc : DES, AES

### Question 2 : 
Soit m = 0x0123456789ABCDEF, k = 0x133457799BBCDFF1 et c = 0x0123456789ABCDEF. On a donc un message m, une clé k et un chiffré c. 

   **Choisir une clé secrète `k` et un message clair `m` de 64 bits chacun** :
   - Par exemple :
     - Message clair `m` : `0x0123456789ABCDEF` (64 bits)
     - Clé secrète `k` : `0x133457799BBCDFF1` (64 bits)

   **Calculer une nouvelle clé `k′`** :
   - Appliquer un XOR entre `k` et la constante `0x0101010101010101` :
     - `k′ = k ⊕ 0x0101010101010101`
     - Si `k = 0x133457799BBCDFF1`, alors :
       - `k′ = 0x133457799BBCDFF1 ⊕ 0x0101010101010101 = 0x123556788ABBDEE0`

   **Chiffrement et déchiffrement** :
   - Chiffrer `m` avec `k` en utilisant DES en mode ECB.
   - Chiffrer `m` avec `k′` en utilisant DES en mode ECB.
   - Comparer les résultats des deux chiffrement.

### Résultat attendu et explication :

- Le chiffrement DES en mode ECB avec deux clés différentes devrait normalement produire des résultats différents pour un même message.
- **Analyse du XOR appliqué sur les clés** :
   - En modifiant légèrement la clé (`k ⊕ 0x0101010101010101`), vous ne changez qu'un bit à chaque octet de la clé.
   - **DES n'est pas linéaire**, ce qui signifie que des modifications légères sur la clé ou le message ne se traduisent pas forcément par des modifications légères dans le texte chiffré. Ainsi, le résultat du chiffrement avec `k′` sera probablement totalement différent du résultat du chiffrement avec `k` (propriété de diffusion).
- Le chiffrement avec la clé modifiée (`k′`) produira un résultat chiffré complètement différent de celui obtenu avec la clé originale (`k`), même si le changement de clé est minime (seulement quelques bits changés). Cela est dû à la nature non linéaire de l'algorithme DES, où de petits changements dans la clé entraînent des changements significatifs dans le résultat chiffré (propriété d'avalanche).

### Question 3 :

### Question 4 :
`m = 0x0123456789ABCDEF` (64 bits) en **hexadécimal** est équivalent à `0000000100100011010001010110011110001001101010111100110111101111` en **binaire**.

Ainsi `m_bar = m ⊕ 0b1111111111111111111111111111111111111111111111111111111111111111 `
Autrement dit, on inverse tous les bits de m et on a `m_bar` en binaire.
Soit `m_bar = 1111111001011100101110101001100001110110010101000011001000000000` en binaire.

k = 0x133457799BBCDFF1 (64 bits) en **hexadécimal** est équivalent à `0001001100110100010101110111100110011011101011111101111111100001` en **binaire**.
De la même manière on déduit `k_bar` en inversant tous les bits de k.
Soit `k_bar = 1110110011001011101010001000011001100100010100000010000000011110` en binaire.

Le résultat du chiffrement de m_bar avec k_bar est `c_bar = 0x3A3B3C3D3E3F3031` en **hexadécimal**. 
Il est attendu que les cryptogrammes obtenus avec m et m_bar soient totalement différents. Cela est dû à la nature non linéaire et la complexité des rondes de chiffrement dans DES.

Non, ce comportement ne représente pas une faille de sécurité de DES. En effet, DES est conçu de manière à ce que des modifications légères (que ce soit dans le message ou dans la clé) entraînent des changements significatifs dans le résultat chiffré, ce qui est une propriété souhaitable d'un bon algorithme de chiffrement (la propriété d'avalanche). Cela signifie que DES résiste bien à des attaques simples basées sur des inversions de bits dans le message.

### Question 5 :
**Algorithme pour trouver les clés faibles :**
#### Clés candidates :

On peut identifier les 4 clés faibles en utilisant deux cas pour C0 et D0 (les moitiés de la clé après PC-1) :
C0 et D0 sont tous à 0.
C0 et D0 sont tous à 1.
Étapes pour générer les sous-clés :

Appliquer la permutation PC-1 à la clé pour obtenir les deux moitiés C0 et D0.
Effectuer des rotations circulaires sur ces moitiés pour chaque tour du chiffrement.
Appliquer la permutation PC-2 pour générer les sous-clés ki à partir des moitiés permutées.
Vérification des clés faibles :

Pour une clé donnée, si toutes les sous-clés générées sont identiques, alors la clé est considérée comme faible.
```python3 
# Permutations PC-1 et PC-2 doivent être définies selon la norme DES
# On simule ici une vérification simplifiée en supposant ces permutations.

def des_generate_subkeys(key):
    # Permutation PC-1 (64 bits -> 56 bits)
    C0, D0 = apply_PC1(key)  # Simuler la permutation PC-1 pour obtenir C0 et D0
    
    # Rotation circulaire pour chaque tour
    subkeys = []
    for i in range(16):
        C_i = rotate_left(C0, i)
        D_i = rotate_left(D0, i)
        # Appliquer PC-2 pour générer une sous-clé
        subkey = apply_PC2(C_i, D_i)
        subkeys.append(subkey)
    
    return subkeys

def is_weak_key(key):
    subkeys = des_generate_subkeys(key)
    # Vérifier si toutes les sous-clés générées sont identiques
    return all(subkey == subkeys[0] for subkey in subkeys)

# Appliquer sur les 4 cas possibles pour C0 et D0
def find_weak_keys():
    weak_keys = []
    
    # Clé 1 : C0 = D0 = tout à 0
    key_1 = generate_key(C0=0b000...0, D0=0b000...0)
    if is_weak_key(key_1):
        weak_keys.append(key_1)
    
    # Clé 2 : C0 = D0 = tout à 1
    key_2 = generate_key(C0=0b111...1, D0=0b111...1)
    if is_weak_key(key_2):
        weak_keys.append(key_2)
    
    # Clé 3 : C0 tout à 0, D0 tout à 1
    key_3 = generate_key(C0=0b000...0, D0=0b111...1)
    if is_weak_key(key_3):
        weak_keys.append(key_3)
    
    # Clé 4 : C0 tout à 1, D0 tout à 0
    key_4 = generate_key(C0=0b111...1, D0=0b000...0)
    if is_weak_key(key_4):
        weak_keys.append(key_4)
    
    return weak_keys
```

### Question 6 :
Soit m_1  = 0X0000000000000000 et m_2 = 0X0000000000000001. On a donc deux messages m_1 et m_2 de 64 bits chacun, avec un seul bit de différence. 
Soit k = 0X1234567890ABCDEF une clé secrète de 64 bits.

#### Application chiffrement DES en ECB sur m1 et m2 avec la clé k :

1. **Chiffrement de m_1 avec k** :
    - Message clair `m_1` : `0X0000000000000000`
    - Clé secrète `k` : `0X1234567890ABCDEF`
    - Résultat chiffré `c_1` : A502016BD4B777CC

2. **Chiffrement de m_2 avec k** :
    - Message clair `m_2` : `0X0000000000000001`
    - Clé secrète `k` : `0X1234567890ABCDEF`
    - Résultat chiffré `c_2` : 2E9C97C23FF6152E

### Résultat attendu et explication :

- Le chiffrement DES en mode ECB avec deux messages qui ne diffèrent que par un seul bit devrait produire des résultats chiffrés totalement différents.
- **Analyse de la propriété d'avalanche** :
    - DES est conçu pour que des modifications légères dans le message (comme un seul bit de différence) entraînent des changements significatifs dans le texte chiffré.
    - Cette propriété garantit que même des messages très similaires produisent des résultats chiffrés très différents, ce qui renforce la sécurité du chiffrement.

### Conclusion :

- Le chiffrement de `m_1` et `m_2` avec la même clé `k` en utilisant DES en mode ECB démontre la propriété d'avalanche de DES.
- Cette propriété est essentielle pour assurer que des messages similaires ne révèlent pas de motifs ou de relations évidentes dans leurs versions chiffrées, augmentant ainsi la robustesse de l'algorithme contre les attaques.



